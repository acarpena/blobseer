.\" This manpage has been automatically generated by docbook2man 
.\" from a DocBook document.  This tool can be found at:
.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
.\" Please send any bug reports, improvements, comments, patches, 
.\" etc. to Steve Cheng <steve@ggi-project.org>.
.TH "GFS_PIO_READDELIM" "3" "13 May 2004" "Gfarm" ""
.SH NAME
gfs_pio_readdelim \- read one record
.SH SYNOPSIS
.sp
\fB#include <gfarm/gfarm.h>
.sp
char *gfs_pio_readdelim (GFS_File \fIf\fB, char **\fIbufp\fB, size_t *\fIsizep\fB, size_t *\fIlenp\fB, char *\fIdelimiter\fB, size_t \fIdelimlen\fB);
\fR
.SH "DESCRIPTION"
.PP
\fBgfs_pio_readdelim()\fR works like 
\fBgfs_pio_readline()\fR, except a delimiter of
input records is not always newline, and can be specified.
This function reads one record from
the file specified by the parameter \fIgf\fR,
by using the parameter \fIdelimiter\fR
as the delimiter of the input records.
You can include '\\0' character in the  \fIdelimiter\fR,
So, you have to specify the length of the \fIdelimiter\fR
by the parameter \fIdelimlen\fR.
If parameter \fIdelimiter\fR is NULL,
this function reads entire file as one record.
Otherwise, and if the parameter \fIdelimlen\fR is 0,
this function treats two or more consecutive empty lines (/\\n\\n+/ in
a regular expression) as the input delimiter. This feature is derived
from INPUT_RECORD_SEPARATOR in perl language.
.PP
Parameter \fIbufp\fR
specifies an address of a pointer variable initialzed by NULL
at first.
\fBgfs_pio_readdelim()\fR allocates a buffer for
I/O dynamically, and stores the address of the buffer to this
variable pointed by \fIbufp\fR.
Parameter \fIsizep\fR specifies an address of
a size_t variable initialized by 0.
This size_t variable is used to record the size of the buffer.
Or, you can specify a buffer allocated by malloc(3) in the
variable pointed by the parameter \fIbufp\fR.
In this case, you have to specify the size of the allocated
buffer by the parameter \fIsizep\fR.
If the length of the record exceeds the size of the buffer, 
the buffer will be automatically realloc(3)ed, and the variable
pointed by \fIbufp\fR and 
\fIsizep\fR will be updated respectively.
Note that you are responsible to free(3) this buffer.
.PP
This function returns the length of the record to a variable
pointed by the parameter \fIlenp\fR.
This length includes the length of the record delimiter.
.PP
This function doesn't remove the delimiter at the end of
records.
Also, despite that you can use the value returned by the
variable pointed by \fIlenp\fR,
this function always appends \\0' character at the end of
records.
.PP
If the file reaches its end, the length of the result record becomes 0.
.PP
gfs_pio_readdelim(f, bufp, sizep, lenp, "\\n", 1)
is equivalent to \fBgfs_pio_readline()\fR function.
.SH "RETURN VALUES"
.TP
\fBNULL\fR
The function terminated successfully.
.TP
\fBGFARM_ERR_NO_MEMORY\fR
Insufficient memory was available.

Note that you need to free(3) the buffer pointed by the
parameter \fIbufp\fR
.TP
\fBOthers\fR
An error except the above occurred.  The reason is shown by its
pointed strings.
.SH "EXAMPLES"
.SS "EXAMPLE OF GFS_PIO_READDELIM FUNCTION"
.PP

.nf
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gfarm/gfarm.h>

int
main(int argc, char **argv)
{
	char *e;
	GFS_File gf;
	size_t bufsize = 0, delimlen = 1, len;
	char *buffer = NULL, *delim = "\\n";

	e = gfarm_initialize(&argc, &argv);
	if (e != NULL) {
		fprintf(stderr, "gfarm_initialize: %s\\n", e);
		return (EXIT_FAILURE);
	}
	while ((c = getopt(argc, argv, "d:D")) != -1) {
		switch (c) {
		case 'd':
			delim = optarg;
			delimlen = strlen(optarg);
			break;
		case 'D':
			delim = NULL;
			delimlen = 0;
			break;
		case '?':
		default:
			fprintf(stderr, "invalid option: %c\\n", c);
			return (EXIT_FAILURE);
		}
	}
	if (optind >= argc) {
		fprintf(stderr, "missing gfarm filename\\n");
		return (EXIT_FAILURE);
	}
	e = gfs_pio_open(argv[optind], GFARM_FILE_RDONLY, &gf);
	if (e != NULL) {
		fprintf(stderr, "%s: %s\\n", argv[optind], e);
		return (EXIT_FAILURE);
	}
	e = gfs_pio_set_view_global(gf, 0);
	if (e != NULL) {
		fprintf(stderr, "%s: gfs_pio_set_view_global: %s\\n",
		    argv[optind], e);
		return (EXIT_FAILURE);
	}

	while ((e = gfs_pio_readdelim(gf, &buffer, &bufsize, &len,
	    delim, delimlen)) == NULL && len > 0) {
		printf("<%6d/%6d >%s", len, bufsize, buffer);
	}
	if (buffer != NULL)
		free(buffer);
	if (e != NULL) {
		fprintf(stderr, "ERROR: %s\\n", e);
		return (EXIT_FAILURE);
	}
	e = gfs_pio_close(gf);
	if (e != NULL) {
		fprintf(stderr, "gfs_pio_close: %s\\n", e);
		return (EXIT_FAILURE);
	}
	e = gfarm_terminate();
	if (e != NULL) {
		fprintf(stderr, "gfarm_initialize: %s\\n", e);
		return (EXIT_FAILURE);
	}
	return (EXIT_SUCCESS);
}
.fi
.SH "SEE ALSO"
.PP
\fBgfs_pio_open\fR(3),
\fBgfs_pio_getline\fR(3),
\fBgfs_pio_gets\fR(3),
\fBgfs_pio_readline\fR(3)
